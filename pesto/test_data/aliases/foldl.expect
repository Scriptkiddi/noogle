[
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 204,
          "column": 5
        },
        "content": "\n      The binary operation to run, where the two arguments are:\n      1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n      2. `x`: The corresponding list element for this iteration\n    ",
        "countApplied": 0
      },
      "attr": {
        "position": {
          "file": "test_data/assets/default.nix",
          "line": 92,
          "column": 25
        },
        "content": null
      }
    },
    "aliases": [
      [
        "lib",
        "lists",
        "foldl'"
      ]
    ],
    "path": [
      "lib",
      "foldl'"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 204,
          "column": 5
        },
        "content": "\n      The binary operation to run, where the two arguments are:\n      1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n      2. `x`: The corresponding list element for this iteration\n    ",
        "countApplied": 0
      },
      "attr": {
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 198,
          "column": 3
        },
        "content": "\n    Reduce a list by applying a binary operator from left to right,\n    starting with an initial accumulator.\n    Before each application of the operator, the accumulator value is evaluated.\n    This behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n    Unlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\n    the initial accumulator argument is evaluated before the first iteration.\n    A call like\n    ```nix\n    foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n    ```\n    is (denotationally) equivalent to the following,\n    but with the added benefit that `foldl'` itself will never overflow the stack.\n    ```nix\n    let\n    acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n    acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n    acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n    ...\n    accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n    accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\n    in\n    accₙ₊₁\n    # Or ignoring builtins.seq\n    op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n    ```\n\n    # Example\n\n    ```nix\n    foldl' (acc: x: acc + x) 0 [1 2 3]\n    => 6\n    ```\n\n    # Type\n\n    ```\n    foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n    ```\n\n    # Arguments\n\n    - [op] The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n    - [acc] The initial accumulator value\n    - [list] The list to fold\n\n  "
      }
    },
    "aliases": [
      [
        "lib",
        "foldl'"
      ]
    ],
    "path": [
      "lib",
      "lists",
      "foldl'"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": true,
        "name": "foldl'",
        "args": [
          "op",
          "nul",
          "list"
        ],
        "experimental": false,
        "arity": 3,
        "content": "\n      Reduce a list by applying a binary operator, from left to right,\n      e.g. `foldl' op nul [x0 x1 x2 ...] : op (op (op nul x0) x1) x2)\n      ...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\n      The return value of each application of `op` is evaluated immediately,\n      even for intermediate values.\n    "
      },
      "attr": {
        "position": null,
        "content": null
      }
    },
    "aliases": [],
    "path": [
      "builtins",
      "foldl'"
    ]
  }
]