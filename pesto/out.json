[
  {
    "docs": {
      "lambda": {
        "isPrimop": true,
        "name": "add",
        "args": [
          "e1",
          "e2"
        ],
        "experimental": false,
        "arity": 2,
        "content": "\n      Return the sum of the numbers *e1* and *e2*.\n    "
      },
      "attr": {
        "position": {
          "file": "test_data/assets/default.nix",
          "line": 68,
          "column": 23
        },
        "content": null
      }
    },
    "aliases": [
      [
        "lib",
        "trivial",
        "add"
      ],
      [
        "builtins",
        "add"
      ]
    ],
    "path": [
      "lib",
      "add"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": true,
        "name": "add",
        "args": [
          "e1",
          "e2"
        ],
        "experimental": false,
        "arity": 2,
        "content": "\n      Return the sum of the numbers *e1* and *e2*.\n    "
      },
      "attr": {
        "position": {
          "file": "test_data/assets/trivial.nix",
          "line": 269,
          "column": 21
        },
        "content": null
      }
    },
    "aliases": [
      [
        "lib",
        "add"
      ],
      [
        "builtins",
        "add"
      ]
    ],
    "path": [
      "lib",
      "trivial",
      "add"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 204,
          "column": 5
        },
        "content": "\n      The binary operation to run, where the two arguments are:\n      1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n      2. `x`: The corresponding list element for this iteration\n    ",
        "countApplied": 0
      },
      "attr": {
        "position": {
          "file": "test_data/assets/default.nix",
          "line": 92,
          "column": 25
        },
        "content": null
      }
    },
    "aliases": [
      [
        "lib",
        "lists",
        "foldl'"
      ]
    ],
    "path": [
      "lib",
      "foldl'"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 204,
          "column": 5
        },
        "content": "\n      The binary operation to run, where the two arguments are:\n      1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n      2. `x`: The corresponding list element for this iteration\n    ",
        "countApplied": 0
      },
      "attr": {
        "position": {
          "file": "test_data/assets/lists.nix",
          "line": 198,
          "column": 3
        },
        "content": "\n    Reduce a list by applying a binary operator from left to right,\n    starting with an initial accumulator.\n    Before each application of the operator, the accumulator value is evaluated.\n    This behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n    Unlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\n    the initial accumulator argument is evaluated before the first iteration.\n    A call like\n    ```nix\n    foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n    ```\n    is (denotationally) equivalent to the following,\n    but with the added benefit that `foldl'` itself will never overflow the stack.\n    ```nix\n    let\n    acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n    acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n    acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n    ...\n    accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n    accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\n    in\n    accₙ₊₁\n    # Or ignoring builtins.seq\n    op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n    ```\n\n    # Example\n\n    ```nix\n    foldl' (acc: x: acc + x) 0 [1 2 3]\n    => 6\n    ```\n\n    # Type\n\n    ```\n    foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n    ```\n\n    # Arguments\n\n    - [op] The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n    - [acc] The initial accumulator value\n    - [list] The list to fold\n\n  "
      }
    },
    "aliases": [
      [
        "lib",
        "foldl'"
      ]
    ],
    "path": [
      "lib",
      "lists",
      "foldl'"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/strings.nix",
          "line": 84,
          "column": 25
        },
        "content": "\n    Map a function over a list and concatenate the resulting strings.\n\n    # Example\n\n    ```nix\n    concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n    => \"afooabar\"\n    ```\n\n    # Type\n\n    ```\n    concatMapStrings :: (a -> string) -> [a] -> string\n    ```\n\n    # Arguments\n\n    - [f] \n    - [list] \n\n  ",
        "countApplied": 1
      },
      "attr": {
        "position": {
          "file": "test_data/assets/strings.nix",
          "line": 243,
          "column": 3
        },
        "content": "\n    Concatenate a list of strings, adding a newline at the end of each one.\n    Defined as `concatMapStrings (s: s + \"\\n\")`.\n\n    # Example\n\n    ```nix\n    concatLines [ \"foo\" \"bar\" ]\n    => \"foo\\nbar\\n\"\n    ```\n\n    # Type\n\n    ```\n    concatLines :: [string] -> string\n    ```\n  "
      }
    },
    "aliases": [],
    "path": [
      "lib",
      "strings",
      "concatLines"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": false,
        "position": {
          "file": "test_data/assets/strings.nix",
          "line": 84,
          "column": 25
        },
        "content": "\n    Map a function over a list and concatenate the resulting strings.\n\n    # Example\n\n    ```nix\n    concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n    => \"afooabar\"\n    ```\n\n    # Type\n\n    ```\n    concatMapStrings :: (a -> string) -> [a] -> string\n    ```\n\n    # Arguments\n\n    - [f] \n    - [list] \n\n  ",
        "countApplied": 1
      },
      "attr": {
        "position": {
          "file": "test_data/assets/default.nix",
          "line": 98,
          "column": 27
        },
        "content": null
      }
    },
    "aliases": [],
    "path": [
      "lib",
      "concatLines"
    ]
  },
  {
    "docs": {
      "lambda": {
        "isPrimop": true,
        "content": "\n      Return the sum of the numbers *e1* and *e2*.\n    ",
        "countApplied": 0
      },
      "attr": {
        "position": null,
        "content": ""
      }
    },
    "aliases": [
      [
        "lib",
        "add"
      ],
      [
        "lib",
        "trivial",
        "add"
      ]
    ],
    "path": [
      "builtins",
      "add"
    ]
  }
]