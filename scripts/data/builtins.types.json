{
  "abort": { "fn_type": "abort :: string" },
  "add": { "fn_type": "add :: number -> number -> number" },
  "all": { "fn_type": "all :: (a -> bool) -> [a] -> bool" },
  "any": { "fn_type": "any :: (a -> bool) -> [a] -> bool" },
  "attrNames": { "fn_type": "attrNames :: AttrSet -> [a]" },
  "attrValues": { "fn_type": "attrValues :: AttrSet -> [a]" },
  "baseNameOf": { "fn_type": "baseNameOf :: string -> string" },
  "bitAnd": { "fn_type": "bitAnd :: int -> int -> int" },
  "bitOr": { "fn_type": "bitOr :: int -> int -> int" },
  "bitXor": { "fn_type": "bitXor :: int -> int -> int" },
  "break": { "fn_type": "break :: a -> a" },
  "catAttrs": { "fn_type": "cattAtrs :: string -> [AttrSet] -> [a]" },
  "ceil": { "fn_type": "ceil :: double -> int" },
  "compareVersions": {
    "fn_type": "compareVersions :: string -> string -> int"
  },
  "concatLists": { "fn_type": "concatLists :: [list] -> []" },
  "concatMap": { "fn_type": "concatMap :: (a -> b) -> [a] -> [b]" },
  "concatStringsSep": {
    "fn_type": "concatStringsSep :: string -> [string] -> string"
  },
  "deepSeq": { "fn_type": "deepSeq :: a -> b -> b" },
  "dirOf": { "fn_type": "dirOf :: string -> string" },
  "div": { "fn_type": "div :: number -> number -> number" },
  "elem": { "fn_type": "elem :: a -> [b] -> bool" },
  "elemAt": { "fn_type": "elemAt :: [a] -> int -> b" },
  "fetchClosure": { "fn_type": "fetchClosure :: attrSet -> attrSet" },
  "fetchGit": { "fn_type": "fetchgit :: attrSet -> attrSet" },
  "fetchTarball": { "fn_type": "fetchTarball :: attrSet -> attrSet" },
  "fetchurl": { "fn_type": "fetchurl :: string -> attrSet" },
  "filter": { "fn_type": "filter :: (a -> bool) -> [a] -> [b]" },
  "filterSource": {
    "fn_type": "filterSource :: (path :: string -> type :: string -> bool) -> path -> storePath :: string"
  },
  "floor": { "fn_type": "floor :: double -> int" },
  "foldl'": {
    "fn_type": "foldl' :: (acc :: a -> curr :: b -> c) -> init :: a -> [b] -> c"
  },
  "fromJSON": { "fn_type": "fromJSON :: string -> a" },
  "functionArgs": { "fn_type": "functionArgs :: (a) -> attrSet" },
  "genList": { "fn_type": "genList :: (a -> b) -> a -> [b]" },
  "genericClosure": { "fn_type": "genericClosure :: attrSet -> [attrSet]" },
  "getAttr": { "fn_type": "getAttr :: string -> attrSet -> a" },
  "getEnv": { "fn_type": "getEnv :: string -> string" },
  "getFlake": { "fn_type": "getFlake :: attrSet -> attrSet" },
  "groupBy": { "fn_type": "groupBy :: (a -> b) -> [a] -> attrSet" },
  "hasAttr": { "fn_type": "hasAttr :: string -> attrSet -> bool" },
  "hashFile": { "fn_type": "hashFile :: string -> path -> string" },
  "hashString": { "fn_type": "hashString :: string -> string -> string" },
  "head": { "fn_type": "head :: [a] -> a" },
  "import": { "fn_type": "import :: path -> a" },
  "intersectAttrs": {
    "fn_type": "intersectAttrs :: attrSet -> attrSet -> attrSet"
  },
  "isAttrs": { "fn_type": "isAttrs :: a -> bool" },
  "isBool": { "fn_type": "isBool :: a -> bool" },
  "isFloat": { "fn_type": "isFloat :: a -> bool" },
  "isFunction": { "fn_type": "isFunction :: a -> bool" },
  "isInt": { "fn_type": "isInt :: a -> bool" },
  "isList": { "fn_type": "isList :: a -> bool" },
  "isNull": { "fn_type": "isNull :: a -> bool" },
  "isPath": { "fn_type": "isPath :: a -> bool" },
  "isString": { "fn_type": "isString :: a -> bool" },
  "length": { "fn_type": "length :: [a] -> int" },
  "lessThan": { "fn_type": "lessThan :: number -> number -> bool" },
  "listToAttrs": {
    "fn_type": "listToAttrs :: [{name :: string; value :: a}] -> attrSet"
  },
  "map": { "fn_type": "map :: (a -> b) -> [a] -> [b]" },
  "mapAttrs": { "fn_type": "mapAttrs :: (a -> b -> c) -> attrSet -> attrSet" },
  "match": { "fn_type": "match :: string -> string -> bool" },
  "mul": { "fn_type": "mul :: number -> number -> number" },
  "parseDrvName": { "fn_type": "parseDrvName :: string -> attrSet" },
  "partition": { "fn_type": "partition :: (a -> bool) -> [a] -> attrSet" },
  "path": { "fn_type": "path :: attrSet -> storePath" },
  "pathExists": { "fn_type": "pathExists :: path -> bool" },
  "placeholder": { "fn_type": "placeholder :: string -> string" },
  "readDir": { "fn_type": "readDir :: path -> attrSet" },
  "readFile": { "fn_type": "readFile :: path -> string" },
  "removeAttrs": { "fn_type": "removeAttrs :: attrSet -> [a] -> attrSet" },
  "replaceStrings": {
    "fn_type": "replaceStrings :: [string] -> [string] -> string -> string"
  },
  "seq": { "fn_type": "seq :: a -> b -> b" },
  "sort": { "fn_type": "sort :: (a -> b -> bool) -> [a] -> [b]" },
  "split": { "fn_type": "split :: string -> string -> [string]" },
  "splitVersion": { "fn_type": "splitVersion :: string -> [string]" },
  "storePath": { "fn_type": "storePath :: storePath -> storePath" },
  "stringLength": { "fn_type": "stringLength :: string -> int" },
  "sub": { "fn_type": "sub :: number -> number -> number" },
  "substring": { "fn_type": "substring :: int -> int -> string -> string" },
  "tail": { "fn_type": "tail :: [a] -> a" },
  "throw": { "fn_type": "throw :: string" },
  "toFile": { "fn_type": "toFile :: path -> string -> storePath" },
  "toJSON": { "fn_type": "toJSON :: a -> string" },
  "toPath": { "fn_type": "toPath :: string -> path" },
  "toString": { "fn_type": "toString :: a -> string" },
  "toXML": { "fn_type": "toXML :: a -> string" },
  "trace": { "fn_type": "trace :: a -> b -> b" },
  "traceVerbose": { "fn_type": "traceVerbose :: a -> b -> b" },
  "tryEval": { "fn_type": "tryEval :: a" },
  "typeOf": { "fn_type": "typeOf :: a -> string" },
  "zipAttrsWith": {
    "fn_type": "zipAttrsWith :: (name:: string -> values :: [a]) -> [a] -> attrSet"
  }
}
